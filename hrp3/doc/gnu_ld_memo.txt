													TOPPERS Confidential
		TOPPERSプロジェクト 設計メモ
		GNUリンカに関するメモ

		作成者: 高田広章（名古屋大学）
		最終更新: 2018年8月12日

○メモの位置付け

このメモは，GNUリンカの仕様と振る舞いに関する調査結果と，TOPPERS/HRP3
カーネルのGNUリンカ向けリンカスクリプト生成（arch/gnu/ldscript.trb）に
関するメモである．

このメモは，GNUリンカのマニュアルおよび以下のバージョンのGNUリンカの動
作を調査することによって作成したものである．

	arm-none-eabi-ld
	GNU ld (GNU Binutils) 2.23.2.20140228

異なるバージョンのGNUリンカは異なる動作をする可能性があるため，注意する
こと．

○目次

・TIPS
	- セクションの調査方法
・セクション出力記述のシンタックス
・ライブラリのリンク
・位置カウンタ（'.'）の振舞い
・LMA指定の有効範囲
・VMAとLMAのアラインの関係
・セクション出力記述の方法
・HRP3開発時の経緯

○TIPS

●セクションの調査方法

objdumpに-hオプションを付けることで，各セクションのサイズ，VMA，LMA等を
調べることができる．

○セクション出力記述のシンタックス

GNUリンカのリンカスクリプトにおいて，SECTIONSコマンドの内側に記述する
セクション出力記述のシンタックスは次の通り．

	セクション名 ［配置番地］［(タイプ)］:［属性］{
		セクション出力コマンド
		セクション出力コマンド
		...
	} ［> リージョン］［AT > LMAリージョン］

タイプには，NOLOAD（プログラム実行時にロードしない）などを，属性には，
アラインメント制約やLMAの指定，その他の制約が記述できる．この他に，
PHDR（ELFのプログラムヘッダ）やフィルパターンを記述するシンタックスが
ある．

○ライブラリのリンク

ライブラリ（アーカイブ）中のどの関数をリンクするかは，ライブラリをリン
クする記述を読んだ時点での未定義のシンボルから決定される．そのため，ラ
イブラリをリンクする記述は，他のオブジェクトファイルをリンクする記述の
後に行う必要がある．

一方，リンカスクリプト中では，オブジェクトファイルやライブラリをリンク
する記述の順序は，メモリ上での配置順序に依存する．そのため，ライブラリ
をリンクする記述が最後に置けるとは限らない．

具体的には，保護ドメイン共通の標準ROMリージョンは，初期化データセクショ
ンの初期値を置くために，リンカスクリプト中の最初に置きたい一方で，ライ
ブラリリンクのためには最後に置きたい．1つのメモリリージョンの記述を2箇
所に分割することは可能だが，分割した間に初期化データセクションの初期値
が置かれると，メモリオブジェクトが分割され，MPUを用いた場合のメモリ保
護設定に悪影響を与える可能性がある．

GNUリンカのリンカスクリプトでは，あるライブラリのいずれかのセクション
をリンクする記述が登場した時点で，そのライブラリ中のどの関数をリンクす
るかが決定される（動作を調査した結果）．この性質を使って，リンカスクリ
プトの先頭に，実際には存在しないセクションをリンクする記述（下に例を示
す）を入れることで，その時点でライブラリ中のどの関数をリンクするかを決
定させる．これにより，その後の記述においては，ライブラリをリンクする記
述を，他のオブジェクトファイルをリンクする記述の後に行う必要がなくなる．

	.discard (NOLOAD) : {
		start.o(.discard) test.o(.discard) kernel_cfg.o(.discard) kernel_mem.o(.discard) -lkernel(.discard) -lc(.discard) -lgcc(.discard) 
	}

○位置カウンタ（'.'）の振舞い

位置カウンタは，セクション記述中では，セクションの先頭からのオフセット
を示す．セクション記述中で，変数に'.'を代入すると絶対アドレスが入るよう
に見えるが，実際には，セクションの先頭からの相対アドレスが入っている．

セクション記述の外側（SECTIONSコマンドの内側）では，最後に配置したセク
ションの終了番地の次の番地を指す（初期値は0）．

また，変数としてはアクセスできないが，内部的に，メモリリージョン毎の配
置位置を保持している．配置先メモリリージョンを指定してセクションを配置
した場合には，位置カウンタではなく，メモリリージョン毎の配置位置から配
置される．

○LMA指定の有効範囲

セクションのLMAを一度変更すると，後続のセクションにもそれが引き継がれ
る（リンカスクリプトの文法からは，引き継がれないように見えるが…）．こ
れは，「AT(<LMAアドレス>)」についても，「AT > <リージョン>」についても
同様である．この振舞いは，不具合ではなく，仕様のようである．

そのため，LMAを変更したセクションの後に，LMAとVMAが一致するセクション
を配置する場合には，LMAを元に戻す（LMAをVMAと一致させる）必要がある．

方法1）LMAを元に戻す記述として，当初，「> RAM AT > RAM」のような記述を
使っていた．しかしこの記述では，RAM上の別の場所にデータがロードされる
（LMAとVMAが別々になる）場合がある．そのため，この記述は，LMAを元に戻
す記述としては，不適切であると思われる．

方法2）セクションの配置番地を指定した場合には，LMAは引き継がれない．そ
こで，セクションの配置番地を指定することで，LMAを元に戻す方法がある．

その他に，セクションの属性に「AT(.)」などを付与することで，LMAを元に戻
せるかもしれない（未調査）．

○VMAとLMAのアラインの関係

セクションの属性にアラインメント制約を記述すると，VMAとLMAの両方に適用
される．LMAをページ単位（メモリ保護ができる単位）にアラインさせる必要
はないため，ページ単位のアライン記述を，セクションの属性のアラインメン
ト制約に記述するのは適切ではない．

セクション記述中にアラインさせるための記述「. = ALIGN(X)」を入れた場合，
アライン指定により確保されたメモリ領域も，LMA側に配置される．そのため，
データセクションの初期値をROMに配置する場合，セクション記述中にアライ
ンさせるための記述（特に，大きい単位にアラインさせるための記述）を入れ
ない方がよい．

○セクション出力記述の方法

以上を踏まえて，セクションをページ単位にアラインさせるためのセクション
出力記述の方法を検討する．

以下では，.section1の後に，.section2を4K単位にアラインさせて配置する例
を考える．.section1はLMAをROMに設定し，.section2はLMAを設定しないもの
とする．

方法A）正しくアラインできない方法

	.section1 : {
		<セクション出力コマンド>
	} > RAM AT > ROM
	. = ALIGN(4K);
	.section2 : {
		<セクション出力コマンド>
	} > RAM AT > RAM

上述の位置カウンタ（'.'）の振舞いより，.section2は位置カウンタが指す番
地から配置されるわけではない．そのため，.section2の先頭番地は4KB境界に
アラインされない．

方法B）ALIGNさせるための記述を.section1のセクション記述中に入れる

	.section1 : {
		<セクション出力コマンド>
		. = ALIGN(4K);
	} > RAM AT > ROM
	.section2 : {
		<セクション出力コマンド>
	} > RAM AT > RAM

上述のVMAとLMAのアラインの関係から，.section1内でALIGNさせるための記述
により確保されたメモリ領域も，ROM側に確保されてしまうという問題がある．

方法C）アライン用のセクションを設ける

	.section1 : {
		<セクション出力記述>
	} > RAM > ROM
	. = ALIGN(4K);
	.dummy . : {
		__dummy = .;
	} > RAM
	.section2 : {
		<セクション出力記述>
	} > RAM

アライン用のダミーセクションができるため綺麗でない以外には，問題はない．
なお，セクションの中が空の場合には何も処理しないため，__dummyラベルを
定義してそれを防いでいる．また，ダミーセクションに配置番地を指定してい
るため，「> RAM AT > RAM」は必要ない．

方法D）.section2の配置番地を指定する

	.section1 : {
		<セクション出力記述>
	} > RAM AT > ROM
	. = ALIGN(4K)
	.section2 . : {
		<セクション出力記述>
	} > RAM

同じメモリリージョンに配置するセクションが連続している場合にしか使用で
きないという制限がある（位置カウンタは，最後に配置したセクションのメモ
リリージョン中の終了番地の次の番地を指すため）．メモリリージョン毎の配
置位置を保持している変数にアクセスできるとこの制限を外せると思われるが，
アクセスする方法はなさそうである．

その後に判明：位置カウンタを変更するためのダミーセクションを用いること
で，この制限を外すことができるようだ．具体的には，以下のような記述とな
る．

	.dummy : {
		__dummy = .;
	} > RAM
	. = ALIGN(4K)
	.section3 . : {
		<セクション出力記述>
	} > RAM

方法D'）配置番地の指定にALIGN記述を入れる

	.section1 : {
		<セクション出力記述>
	} > RAM AT > ROM
	.section2 ALIGN(4K) : {
		<セクション出力記述>
	} > RAM

方法Dと同じ制限（とそれを外す方法）がある．

方法E）.section2にアラインメント制約を記述する

	.section1 : {
		<セクション出力記述>
	} > RAM AT > ROM
	.section2 : ALIGN(4K) {
		<セクション出力記述>
	} > RAM AT > RAM

初期化が必要なセクションをこの方法でリンクすると，ROMに配置される初期
化データまでページ境界にアラインされてしまうという問題がある．この例は
該当しないが，.section2のLMAをROMに設定すると問題になる．

この問題を回避する方法として，初期化が必要なセクションについては，初期
化が必要なセクションの手前にダミーセクションを置く必要がある．

	.section1_align : ALIGN(4K) {
		__align_section1 = .;
	} > RAM
	.section1 . : ALIGN(4) {
		<セクション出力記述>
	} > RAM AT > ROM
	.section2 : ALIGN(4K) {
		<セクション出力記述>
	} > RAM AT > RAM

○HRP3開発の経緯

HRP2カーネルの実装では，方法D（セクションの配置番地はALIGN(4)としてい
た）を用いていた．メモリリージョンの先頭のセクションとLNK_SECで登録し
たセクションに対しては，配置番地を指定していなかった．また，LMAを元に
戻すために，「> RAM AT > RAM」のような記述を使っていた．

HRP3カーネルの実装では，やり方が二転している．

当初はHRP2カーネルの方法を踏襲していた．この時に調査したところ，LMAを
元に戻す記述は必要ないという結果になり（セクションの配置番地を指定して
いたため），LMAを元に戻す記述を削除した（[71]）．

その後，方法Eを用いるように変更した（[210]）．1つの理由は，LNK_SECで登
録したセクションについても方法Dを適用しようとすると，方法Dの制限が問題
になることである．この変更により，セクションの配置番地を指定しないと
LMAを元に戻す必要があることが判明したため，LMAを元に戻す「> RAM AT >
RAM」のような記述を復活させた（[209]）．LNK_SECは，その後廃止となって
いる．

その後，「> RAM AT > RAM」のような記述が不適切であることが判明し，方法
D'に変更した（[349]）．メモリリージョンの先頭のセクションの配置番地に
は，メモリリージョンの先頭番地を指定する（これにより，すべてのセクショ
ン出力記述に配置番地を指定する）．現在のメモリ配置方法では，LNK_SECが
廃止されており，メモリオブジェクトを最初にメモリリージョン毎にソートす
るため，方法D'の制限は障害にならない．

以上
