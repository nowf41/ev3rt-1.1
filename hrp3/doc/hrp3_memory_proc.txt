													TOPPERS Confidential
		TOPPERSプロジェクト 設計メモ
		メモリに関するコンフィギュレーション処理

		作成者: 高田広章（名古屋大学）
		最終更新: 2018年12月27日

○メモの位置づけ

このメモは，TOPPERS/HRP3カーネルにおけるメモリに関するコンフィギュレー
ション処理に関してまとめたものである．

○目次

・用語の定義
・自動メモリ配置と手動メモリ配置
	- 自動メモリ配置
	- 手動メモリ配置
・コンフィギュレーションの流れ
	- メモリ構成・初期化ファイルの生成に必要な情報
	- 各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地の決定
	- 自動メモリ配置の場合のコンフィギュレーションの流れ
	- 手動メモリ配置の場合のコンフィギュレーションの流れ
・コンフィギュレータのパス2〜4の処理の詳細
	- パス2（自動メモリ配置の場合）の詳細
	- パス3（自動メモリ配置の場合のみ）の詳細［USE_CFG_PASS3の場合のみ］
	- パス4（自動メモリ配置の場合のみ）の詳細
	- パス2（手動メモリ配置の場合）の詳細
・自動メモリ配置と手動メモリ配置の中間的な方法（参考情報）
	- 方法の概要
	- 方法の具体化

○用語の定義

・リンクオンリーセクション

ATT_SECにより，メモリオブジェクト属性にTA_NOWRITE属性とTA_NOREAD属性を
指定し，TA_EXEC属性を指定せずに登録したセクションは，リンカによって配
置されるだけで，メモリオブジェクトとしてカーネルに登録されない
［NGKI3962］．これを，リンクオンリーセクションと呼ぶ．

○自動メモリ配置と手動メモリ配置

オブジェクトモジュールやセクションのメモリ配置（どの番地に配置するか）
を決定する方法として，コンフィギュレータが決定する自動メモリ配置と，ユー
ザに決定させる手動メモリ配置がある．

HRP1カーネルは手動メモリ配置のみを，HRP2カーネルは自動メモリ配置のみを
サポートしていたが，HRP3カーネルでは両方をサポートすることとする．ただ
し，HRP3カーネルにおける手動メモリ配置は，HRP1カーネルのものより制約が
強い．

オブジェクトモジュールやセクションのメモリ配置は，リンカスクリプトで決
定される．それに対して，どの番地をどのように保護するかは，メモリ構成・
初期化ファイル（kernel_mem.c）で決定される．そのため，リンカスクリプト
とメモリ構成・初期化ファイルは，整合した内容となっていなければならない．

●自動メモリ配置

オブジェクトモジュールやセクションをどのように保護するかをコンフィギュ
レーション記述に含め，それらをどの番地に配置するかをコンフィギュレータ
が決定する方法．コンフィギュレータは，リンカスクリプトとメモリ構成・初
期化ファイルを，整合した内容となるように生成する．

自動メモリ配置では，ATT_REG，DEF_SRG，ATT_SEC，ATT_MOD，ATT_MEMのすべ
ての静的APIを用いる．

●手動メモリ配置

オブジェクトモジュールやセクションのメモリ配置を，ユーザに決定させる方
法．ユーザは，リンカスクリプトを用意するとともに，どの番地をどのように
保護するかをコンフィギュレーション記述に含める．メモリ構成・初期化ファ
イルは，コンフィギュレーション記述からコンフィギュレータが生成する．リ
ンカスクリプトとコンフィギュレーション記述（どの番地をどのように保護す
るか）の内容が整合するようにするのは，ユーザの責任である．

手動メモリ配置では，ATT_MEMのみを用いる．ATT_REG，DEF_SRG，ATT_SEC，
ATT_MODは意味がない．

手動メモリ配置の欠点は，メモリ配置を決めるために，ユーザが，ターゲット
プロセッサのメモリ保護機能を知っていることが必要なことである．リンカス
クリプトは，当然，ターゲットプロセッサ依存になる．

また，手動メモリ配置には，dataセクションとbssセクションの初期化情報を
ユーザが記述しなければならないという欠点がある（セクションをカーネルに
登録していないため，コンフィギュレータで生成できない）．

○コンフィギュレーションの流れ

手動メモリ配置の場合のコンフィギュレーションの流れは，ASP3カーネルと同
じである．実際には，ASP3カーネルと同じ流れでコンフィギュレーションがで
きるように，手動メモリ配置の場合のAPI仕様を定めている．

自動メモリ配置の場合のコンフィギュレーションの流れは，「TOPPERS第3世代
カーネル（ITRON系）統合仕様書」の「2.12.5 コンフィギュレータの処理モデ
ル」の節に，「保護機能対応カーネルで自動メモリ配置の場合」として記載し
ている．

以下では，自動メモリ配置のコンフィギュレーションの流れについて説明する．

●メモリ構成・初期化ファイルの生成に必要な情報

メモリ構成・初期化ファイル（kernel_mem.c）には，メモリオブジェクト初期
化情報，dataセクション初期化ブロック，bssセクション初期化ブロックに加
えて，メモリ保護設定に必要なターゲット依存の情報を生成する．

メモリオブジェクト初期化情報は，ターゲット依存の最適化したい場合がある．
これを可能にするために，OMIT_STANDARD_MEMINIBを定義した場合には，メモ
リオブジェクト初期化情報を生成しない．OMIT_STANDARD_MEMINIBを定義しな
い場合に生成するメモリオブジェクト初期化情報を，「標準のメモリオブジェ
クト初期化情報」と呼ぶ．

標準のメモリオブジェクト初期化情報を生成するためには，少なくとも，メモ
リオブジェクトの配置順序がわかっている必要がある．また，空のメモリオブ
ジェクトがわかると，テーブル中の不要なエントリを減らすことができる．さ
らに，各メモリオブジェクトの先頭番地と終了番地がわかると，メモリオブジェ
クトが連続配置されているかどうかがわかるため，テーブル中の不要なエント
リを無くすことができる．

また，空のセクションがわかると，dataセクション初期化ブロックおよびbss
セクション初期化ブロック中の不要なエントリを無くすことができる．

メモリ保護設定に必要なターゲット依存の情報を生成するために必要な情報は
（もちろん）ターゲット依存であるが，メモリ管理ユニット（MMU）を持つター
ゲットプロセッサ向けにアドレス変換テーブル（ページテーブル等）を生成す
るためには，各メモリ保護単位の先頭番地と終了番地がわかっていることが必
要になる．

これらのことから，HRP3カーネルでは，メモリ構成・初期化ファイルを生成す
る段階で，各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地がわ
かっているものとする．

このことから，自動メモリ配置では，メモリ構成・初期化ファイルの生成はコ
ンフィギュレータのパス2で行うことができず，パス3以降で行うことになる．

また，手動メモリ配置では，静的APIのみから各メモリ保護単位／メモリオブ
ジェクトの先頭番地と終了番地がわかるように，API仕様を定める必要がある．

●各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地の決定

自動メモリ配置において，各メモリ保護単位／メモリオブジェクトの先頭番地
と終了番地を決定するためには，少なくとも，各メモリ保護単位／メモリオブ
ジェクトのサイズがわかっていることが必要である．

各メモリオブジェクトのサイズはオブジェクトファイル（.oファイル）から取
り出すことで，各メモリ保護単位のサイズはそれに含まれるメモリオブジェク
トのサイズを合計することで，おおよそは求めることができる．しかし，アラ
インメント制約やリンカによる最適化がある場合には，この方法で正確なサイ
ズを求められるとは限らない．

そこで，HRP3カーネルでは，コンフィギュレータのパス2では仮のメモリ構成・
初期化ファイル（kernel_mem2.c）を生成し，それを用いて生成した仮のロー
ドモジュールから，各メモリ保護単位／メモリオブジェクトの先頭番地と終了
番地を取り出す方法をとる．

ここで，以下の(a)と(b)の2つの課題がある．

(a) テーブルのサイズの決定方法

仮のメモリ構成・初期化ファイルに生成する各種のテーブル（配列）のサイズ
をどのように決定するかが課題である．

例えば，標準のメモリオブジェクト初期化情報に含まれるテーブルのサイズは，
空のメモリオブジェクトがある場合や，メモリオブジェクトが連続配置されて
いる場合には小さくなる．

メモリオブジェクトが空かどうかは，コンフィギュレータのパス2では判別で
きない．また，メモリオブジェクトが連続配置されているかどうかは，コンフィ
ギュレータが配置を決めるメモリオブジェクト間についてはパス2で（おおよ
そ）判別できるが，そうでないものについては判別できない．そこでコンフィ
ギュレータのパス2では，空のメモリオブジェクトはなく，判別できる場合を
除いてメモリオブジェクトは連続配置されていないものとして，テーブルのサ
イズを決定する．その結果，必要以上に大きいテーブルが確保されてしまう可
能性がある．

最終的なメモリ構成・初期化ファイルの生成時に，このテーブルを必要なサイ
ズに縮小すると，メモリ保護単位／メモリオブジェクトの先頭番地と終了番地
が変化してしまう可能性がある．そのため，テーブルのサイズは，パス2で決
定したもの（つまり，必要以上に大きい可能性があるもの）と同じにしなけれ
ばならない．

テーブルのサイズが必要以上に大きくなる問題が無視できない場合には，パス
2の後に最適化のためのパス3を追加し，最終的なメモリ構成・初期化ファイル
はパス4で生成する方法が考えられる．パス3においては，パス2で生成した仮
のロードモジュールからメモリオブジェクトが空かどうかの情報を取り出し，
それを用いてテーブルのサイズを小さくできる可能性がある．ただし，パス3
においても，メモリオブジェクトが連続配置されるかどうかを正確に判別する
ことはできない（パス2で生成した仮のロードモジュールでは連続配置されて
いたメモリオブジェクトが，テーブルのサイズを小さくすることで，連続配置
されなくなる可能性があるため）．

同様に，dataセクション初期化ブロックとbssセクション初期化ブロックのサ
イズについても，パス3を追加することで，小さくできる可能性がある．さら
に，メモリ保護設定に必要なターゲット依存の情報についても，同様の最適化
が行える可能性がある．

(b) メモリ保護単位にサイズ依存の配置制約がある場合への対応

ARMv7以前のメモリ保護ユニット（MPU）のように，メモリ保護単位のアライン
メント制約がメモリ保護単位のサイズに依存する場合には，コンフィギュレー
タのパス2で生成する仮のロードモジュールでは，アラインメント制約を満た
すことができない．

このような場合には，パス2で生成した仮のロードモジュールからメモリ保護
単位のサイズを取り出し，パス3で，アラインメント制約を満たすロードモジュー
ルを生成する必要がある．

ここで，各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地が，パ
ス3の中で決定できるかが課題になる．パス3において，パス2で生成した仮の
ロードモジュールから取り出した情報から，自分で生成するロードモジュール
における各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地を予測
することは，アラインメント制約やリンカによる最適化がある場合には，難し
いものと思われる．そのため，パス3ではアラインメント制約を満たす仮のロー
ドモジュールを生成し，そこから各メモリ保護単位／メモリオブジェクトの先
頭番地と終了番地を取り出して，パス4において最終的なメモリ構成・初期化
ファイルを生成する．

さらに，メモリ保護単位のアラインメント制約がメモリ保護単位のサイズに依
存する場合には，メモリ保護単位をなるべく詰めて配置できるように，メモリ
保護単位の配置アドレスを最適化することが望ましい．この配置アドレスの最
適化も，パス3で行うことができる．

ただし，アラインメント制約やリンカによる最適化がある場合には，パス3で
メモリ保護単位のアラインメントや配置アドレスを変更した結果，メモリ保護
単位のサイズが変化することがないとは言えない．この状況への対応は，この
ような現象が発生した時点で検討するものとし，現時点では，パス3で生成し
た仮のロードモジュールと，パス4で生成した最終的なロードモジュールで，
メモリ配置が変化していないことを確認することに留める（両者でメモリ配置
が変化していなければ，最終的なロードモジュールは正しいことになる）．

以上より，(a)と(b)の2つの課題に対応するために，HRP3カーネルでは，ター
ゲット依存にパス3を設けられるようにし，最終的なメモリ構成・初期化ファ
イルの生成はパス4で行うこととする．ただし，この方法では，(a)と(b)の課
題の両方に同時に対応することはできない（対応するには，さらにもう1つの
パスが必要になる）．また，上述の通り，(b)の課題への対応に関しては課題
が残っている．

パス3を使用する場合には，Makefileのターゲット依存部で，USE_CFG_PASS3を
trueに設定し，コンパイルオプションに"-DUSE_CFG_PASS3"を与える．

以下では，パス3を使用する場合を，「USE_CFG_PASS3の場合」と呼ぶ．また，
(a)の課題に対応するためにパス3を使用する場合を，パス3でメモリオブジェ
クトのサイズを変更することから，「USE_CFG_PASS3_RESIZEの場合」と呼ぶ．
さらに，(b)の課題に対応するためにパス3を使用する場合を，パス3でメモリ
オブジェクトの配置アドレスを変更することから，「USE_CFG_PASS3_RELOCATE
の場合」と呼ぶ．上に述べた制約により，「USE_CFG_PASS3_RESIZEの場合」と
「USE_CFG_PASS3_RELOCATEの場合」は排他的である．

●自動メモリ配置の場合のコンフィギュレーションの流れ

この節では，HRP3カーネルの自動メモリ配置の場合のコンフィギュレーション
の流れを説明する．また，各パスの処理内容に関して，メモリに関するものを
中心に整理する．

(1) コンフィギュレータ パス1
	※パス1の処理内容はターゲット非依存であり，パス1のための生成スクリ
	　プト（.trbファイル）はない．

・システムコンフィギュレーションファイルの解析
	- 文法エラーの検出
・パラメータ計算用C言語ファイル（cfg1_out.c）の生成
	- 値取得シンボルテーブル（xxx_sym.def）に記述したシンボルの値の算出
	- 条件ディレクティブにより有効になる静的APIの判別
	- 静的APIの整数定数式パラメータの値の算出

(2) パラメータ計算用C言語ファイルのコンパイルとロードモジュールの生成

この段階で決定される情報
	- 値取得シンボルテーブル（xxx_sym.def）に記述したシンボルの値
	- 条件ディレクティブにより有効になる静的API
	- 静的APIの整数定数式パラメータの値

(A3) コンフィギュレータ パス2（target_kernel.trb）

・静的APIの整数定数式パラメータの不正エラーの検出
・カーネル構成・初期化ファイル（kernel_cfg.c）の生成
・カーネル構成・初期化ヘッダファイル（kernel_cfg.h）の生成
・仮のメモリ構成・初期化ファイル（kernel_mem2.c）の生成
	- ユーザが先頭番地とサイズを指定して登録したメモリオブジェクトの先
	  頭番地を求めるために，仮メモリオブジェクト初期化情報の中に，ユー
	  ザが指定した先頭番地の記述（一般定数式パラメータ）を生成する．
・仮のリンカスクリプト（cfg2_out.ld）の生成
	- 最終的なリンカスクリプトと違い，kernel_mem.oをリンクする代わりに，
	  kernel_mem2.oをリンクする．
	- USE_CFG_PASS3の場合には，その他に違いがあってもよい．

(A4) アプリケーションのロードモジュール2の生成

この段階で決定される情報
　［USE_CFG_PASS3でない場合］
	- 各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地
	- 各メモリ保護単位／セクション／メモリオブジェクトのサイズ
　［USE_CFG_PASS3_RESIZEの場合］
	- 各メモリ保護単位／セクション／メモリオブジェクトが空かどうか？
　［USE_CFG_PASS3_RELOCATEの場合］
	- 各メモリ保護単位／セクション／メモリオブジェクトのサイズ

(A5) コンフィギュレータ パス3［USE_CFG_PASS3の場合のみ］（target_opt.trb）

［USE_CFG_PASS3_RESIZEの場合］
・仮のメモリ構成・初期化ファイルの生成を阻害するエラーの検出
・仮のメモリ構成・初期化ファイル（kernel_mem3.c）の生成
	- この段階で，各種のテーブルのサイズを適正化する．
	- kernel_mem3.oのサイズは，kernel_mem2.oと違っていても良い．
	- ユーザが先頭番地とサイズを指定して登録したメモリオブジェクトの先
	  頭番地を求めるために，仮メモリオブジェクト初期化情報の中に，ユー
	  ザが指定した先頭番地の記述（一般定数式パラメータ）を生成する．
・仮のリンカスクリプト（cfg3_out.ld）の生成
	- 最終的なリンカスクリプトとの違いは，kernel_mem.oをリンクする代わ
	  りに，kernel_mem3.oをリンクすることのみ．

［USE_CFG_PASS3_RELOCATEの場合］
・メモリ保護単位のアラインメント／配置アドレスの決定
・仮のメモリ構成・初期化ファイルの生成を阻害するエラーの検出
・仮のメモリ構成・初期化ファイル（kernel_mem3.c）の生成
	- kernel_mem3.oのサイズは，kernel_mem2.oと同じであること．
	※サイズが変わることを見込んでメモリ保護単位のアラインメント／配置
	　アドレスを決定すれば，この制約は外すことができるが，アラインメン
	　ト制約やリンカによる最適化がある場合には，簡単ではないと思われる．
・仮のリンカスクリプト（cfg3_out.ld）の生成
	- 最終的なリンカスクリプトとの違いは，kernel_mem.oをリンクする代わ
	  りに，kernel_mem3.oをリンクすることのみ．

(A6) アプリケーションのロードモジュール3の生成［USE_CFG_PASS3の場合のみ］

この段階で決定される情報
	- 各メモリ保護単位／メモリオブジェクトの先頭番地と終了番地
	- 各メモリ保護単位／セクション／メモリオブジェクトのサイズ

(A7) コンフィギュレータ パス4（target_mem.trb）

・メモリ構成・初期化ファイルの生成を阻害するエラーの検出
	- メモリオブジェクトの重なりをチェックする．
・メモリ構成・初期化ファイル（kernel_mem.c）の生成
	- kernel_mem.oのサイズは，USE_CFG_PASS3の場合はkernel_mem3.oと，そ
	  うでない場合はkernel_mem2.oと同じであること．
・リンカスクリプト（ldscript.ld）の生成
・静的APIの一般定数式パラメータの不正エラーの検出（target_check.trb）
	- メモリ領域の配置のチェックも含む．
	※この段階で，静的APIの一般定数式パラメータの不正エラーが検出でき
	　るのは，次の理由による．ロードモジュール3を生成したの時点で，各
	　メモリ保護単位／セクション／メモリオブジェクトの先頭番地と終了番
	　地およびサイズが決定される．そのため，この段階で，すべてのシンボ
	　ルの値が決定され，静的APIの一般定数式パラメータの値も決定される
	　ためである．

(A8) アプリケーションの最終的なロードモジュールの生成

(A9) メモリ配置が変わっていないことのチェック

・ロードモジュール3と最終的なロードモジュールのシンボルファイルのdiff
　を取ることで実施
	- これにより，想定したメモリ配置になっていることが保証される．

●手動メモリ配置の場合のコンフィギュレーションの流れ

この節では，HRP3カーネルの手動メモリ配置の場合のコンフィギュレーション
の流れを説明する．また，各パスの処理内容に関して，メモリに関するものを
中心に整理する．

(1)〜(2)は，自動メモリ配置の場合と同じである．

(M3) コンフィギュレータ パス2（target_kernel.trb）

・静的APIの整数定数式パラメータの不正エラーの検出
・カーネル構成・初期化ファイル（kernel_cfg.c）の生成
・カーネル構成・初期化ヘッダファイル（kernel_cfg.h）の生成
・メモリ構成・初期化ファイルの生成を阻害するエラーの検出
	- メモリオブジェクトの重なりをチェックする．
・メモリ構成・初期化ファイル（kernel_mem.c）の生成

(M4) アプリケーションの最終的なロードモジュールの生成

(M5) コンフィギュレータ パス3（target_check.trb）

・静的APIの一般定数式パラメータの不正エラーの検出
	- メモリ領域の配置のチェックも含む．

○コンフィギュレータのパス2〜4の処理の詳細

この章では，コンフィギュレータのパス2〜4の処理の詳細について整理する．
ARM向けのターゲット依存部を仮定して記述している．

●パス2（自動メモリ配置の場合）の詳細

(A3-1) ターゲット依存の定義（target_kernel.trb，core_kernel.trb）

(A3-2) メモリリージョンの情報の生成（memory_prep.trb）

・ATT_REGで登録されたメモリリージョンに関するエラーチェックと情報の生成
	$cfgData[:ATT_REG][key][:regname]
								メモリリージョン名（[:region]の二重引用
								符を外したもの）
	$regnameList				メモリリージョン名のリスト

・DEF_SRGで定義された標準メモリリージョンに関するエラーチェックと情報の生成
	$cfgData[:CRE_DOM][domain][:stdrom]
								標準ROMリージョンのメモリリージョン番号
	$cfgData[:CRE_DOM][domain][:stdram]
								標準RAMリージョンのメモリリージョン番号
	$cfgData[:CRE_DOM][domain][:stdsrom]
								標準ショートROMリージョンのメモリリージョン番号
	$cfgData[:CRE_DOM][domain][:stdsram]
								標準ショートRAMリージョンのメモリリージョン番号

(A3-3) 静的APIからのメモリオブジェクトの情報の生成

メモリオブジェクトを登録する静的API（ATT_MOD，ATT_SEC，ATT_MEM／
ATT_PMA，CRE_TSK，CRE_MPF）を処理し，統合前のメモリオブジェクトに関す
る以下の情報を生成する．

	$memObj						メモリオブジェクト情報
	$memObj[key][:type]			メモリオブジェクトのタイプ（:ATTMOD，:ATTSEC，
								:ATTMEM，:USTACK，:MPFAREAのいずれか）
	$memObj[key][:linker]		リンカが配置するメモリオブジェクトか？
	$memObj[key][:domain]		属するドメイン（無所属の場合は$TDOM_NONE）
	$memObj[key][:memreg]		メモリリージョン番号（リンカが配置する場合のみ）
	$memObj[key][:secname]		セクション名（リンカが配置する場合のみ）
	$memObj[key][:mematr]		メモリオブジェクト属性
	$memObj[key][:module]		オブジェクトモジュール名（ATT_MODで登録さ
								れた場合のみ）
	$memObj[key][:base]			先頭番地（ATT_MEM／ATT_PMAで登録された場
								合と，先頭番地を指定して登録されたユーザ
								スタック領域のみ）
	$memObj[key][:size]			サイズ（ATT_MEM／ATT_PMAで登録された場合
								と，ユーザスタック領域のみ）
	$memObj[key][:paddr]		物理アドレス（ATT_PMAで登録された場合のみ）
	$memObj[key][:stkorder]		ユーザスタック領域の配置順序（コンフィギュ
								レータが割り付けるユーザスタック領域のみ）
	$memObj[key][:mpfid]		固定長メモリプールID（コンフィギュレータ
								が割り付ける固定長メモリプール領域のみ）
	$memObj[key][:acptn1]		通常操作1（書込み）のアクセス許可パターン
	$memObj[key][:acptn2]		通常操作2（読出し，実行）のアクセス許可パターン
	$memObj[key][:acptn4]		参照操作のアクセス許可パターン
	$memObj[key][:apiname]		メモリオブジェクトを登録した静的APIの名称
	$memObj[key][:_file_]		メモリオブジェクトを登録した静的APIのファイル名
	$memObj[key][:_line_]		メモリオブジェクトを登録した静的APIの行番号
	$ustackListLinker			コンフィギュレータが割り付ける（リンカが
								配置する）ユーザスタック領域のリスト
	$ustackListUser				先頭番地を指定されたユーザスタック領域の
								リスト

(A3-3-1) 変数の初期化（memory_prep.trb）

	- $lastMOKey（最後に登録したメモリオブジェクトのキー）を0に初期化する．
	- $memObj，$ustackListLinker，$ustackListUserを空の状態に初期化する．

(A3-3-2) オブジェクトモジュールの登録（memory_prep.trb）

・ATT_MODしたのと同等に扱うオブジェクトモジュールの処理
	　［ATT_MODがサポートされていない場合には，この処理は行わない］
	- $cfgData[:ATT_MOD]に，ATT_MODしたのと同等に扱うオブジェクトモジュー
	  ルを追加する．

・ATT_MODで登録されたオブジェクトモジュールに関するエラーチェックと情報の生成
	　［ATT_MODがサポートされていない場合には，E_NOSPTエラーとする］
	- $memObjに，登録されたオブジェクトモジュールの標準のセクションに
	  関する情報を追加する．

(A3-3-3) セクションの登録（memory_prep.trb）

・ATT_SECで登録できないセクション名のリストの作成
	　［この処理は，自動メモリ配置の場合にのみ行う］
	$standardSecnameList		登録できないセクション名のリストの作成

・ATT_SECで登録されたセクションに関するエラーチェックと情報の生成
	$cfgData[:ATT_SEC][key][:secname]
								セクション名（[:section]の二重引用符を外
								したもの）
	- $memObjに，登録されたセクションに関する情報を追加する．

・保護ドメイン毎の標準セクションに関する情報の生成
	　［この処理は，自動メモリ配置の場合にのみ行う］
	- $memObjに，保護ドメイン毎の標準セクションに関する情報を追加する．

(A3-3-4) メモリ領域の登録（memory_prep.trb）

・ATT_MEM／ATT_PMAで登録されたメモリ領域に関するエラーチェックと情報の生成
	　［ATT_PMAがサポートされていない場合に，ATT_PMAを使用した場合には，
		E_NOSPTエラーとする］
	- $memObjに，登録されたメモリ領域に関する情報を追加する．

(A3-3-5) ターゲット依存のメモリオブジェクト情報の操作（memory_prep.trb）

	- メモリオブジェクト情報を操作する関数（TargetMemoryObject）がター
	  ゲット依存部で定義されていた場合には，ここで呼び出す．
	- ARMコア依存部では，$memObjに.page_tableセクションに関する情報を
	  追加する．

(A3-3-6) ユーザスタック領域に関する情報の生成（task.trb）

	- $memObjに，ユーザスタック領域に関する情報を登録する．
	- $ustackListLinkerに，コンフィギュレータが割り付ける（リンカが配置
	  する）ユーザスタック領域を追加する．
	- $ustackListUser，先頭番地を指定されたユーザスタック領域を追加する．

(A3-3-7) レッドゾーン方式の処理（task.trb）
	　［この処理は，レッドゾーン方式を用いている場合にのみ行う］

・レッドゾーン方式におけるユーザスタック領域の配置順序の決定
	- $memObj[key][:stkorder]に，ユーザスタック領域の配置順序を設定する．

・ダミースタック領域に関する情報の生成
	- $memObjに，ダミースタック領域に関する情報を追加する．

(A3-3-8) 固定長メモリプール領域に関する情報の生成（mempfix.trb）

	- $memObjに，固定長メモリプール領域（コンフィギュレータが割り付けた
	  もののみ）に関する情報を追加する．

(A3-4) 統合前のメモリオブジェクトの情報の加工（memory.trb）

メモリオブジェクトのソートと統合の準備として，統合前のメモリオブジェク
トの情報を修正するとともに，各種の属性情報を追加する．

・統合前のメモリオブジェクトの情報に，以下の修正を加える．
	$memObj[key][:acptn1]		メモリオブジェクト属性にTA_NOWRITEが設定
								されている場合は，通常操作1（書込み）の
								アクセス許可パターンを0にする

・統合前のメモリオブジェクトの情報に，以下の情報を追加する．
	$memObj[key][:accatr]		メモリオブジェクトアクセス属性
	$memObj[key][:nowrite]		メモリオブジェクト属性にTA_NOWRITEが設定
								されているか？
	$memObj[key][:linkonly]		リンクオンリーセクションか？
	$memObj[key][:stdregion]	共通の標準ROM/RAMリージョンか？（リンカ
								が配置する場合のみ）
	$memObj[key][:stdmematr]	メモリオブジェクト属性が標準的なものか？
	$memObj[key][:stdaccatr]	メモリオブジェクトアクセス属性が標準的
								なものか？
	$memObj[key][:stdacptn12]	ACPTN1とACPTN2が標準か？
	$memObj[key][:srpw]			標準共有リード専有ライト領域か？
	$memObj[key][:stdacptn4]	ACPTN4が標準か？
	$memObj[key][:sdata]		ショートデータ領域か？
	$memObj[key][:memini]		TA_MEMINI属性が設定された場合と同様に扱
								う（TA_NOWRITE属性のメモリオブジェクトが，
								TA_NOWRITE属性でないメモリリージョンに登
								録された場合）

(A3-5) メモリオブジェクトのソートと統合（memory.trb）

メモリオブジェクトの配置順序の決定のために，メモリオブジェクトをソート
する．ソートするのは，実質的には，リンカが配置するメモリオブジェクトの
みである（リンカが配置しないものは，そのままの順序で最後に置く）．ソー
ト後に連続配置されているメモリオブジェクトで，統合の条件を満たすものを
統合する．統合するのは，ユーザスタック領域を除くリンカが配置するメモリ
オブジェクト（逆に言うと，ATT_SECとATT_MODで登録されたメモリオブジェク
ト）のみである．

・統合前のメモリオブジェクトをソートするための指標を作る
	$memObj[key][:order]		メモリオブジェクトをソートするための指
								標リスト

・メモリオブジェクトのソート
	$memObjを，$memObj[key][:order]の順にソートする

・メモリオブジェクトの統合処理として，次の情報を作成する
	$memObj[key][:SEC_TOP]		セクションの先頭
	$memObj[key][:SEC_LAST]		セクションの最後
	$memObj[key][:MO_TOP]		統合後のメモリオブジェクトの先頭
	$memObj[key][:MO_LAST]		統合後のメモリオブジェクトの最後
	$memObj[key][:MP_TOP]		メモリ保護単位の先頭
	$memObj[key][:MP_LAST]		メモリ保護単位の最後
	$memObj[key][:MEMREG_TOP]	メモリリージョンの先頭
	$memObj[key][:MEMREG_LAST]	メモリリージョンの最後
	$memObj[key][:SRPW_TOP]		標準共有リード専用ライト領域全体の先頭
	$memObj[key][:SRPW_LAST]	標準共有リード専用ライト領域全体の最後
	$memObj[key][:SDATA_TOP]	ショートデータセクションの先頭
	$memObj[key][:moTop]		統合後のメモリオブジェクトの先頭
	$memObj[key][:moLast]		統合後のメモリオブジェクトの最後（統合後の
								メモリオブジェクトの先頭のみに対して設定）
	$memObj[key][:secLast]		セクションの最後（セクションの先頭のみに対
								して設定）
	$memObj[key][:mpLast]		メモリ保護単位の最後（メモリ保護単位の先頭
								のみに対して設定）
	$memObjList					統合後のメモリオブジェクトの先頭のリスト

・メモリオブジェクトのラベルの生成
	$memObj[key][:SLABEL]		セクションのラベル
	$memObj[key][:ILABEL]		初期化データ領域のラベル
	$memObj[key][:MLABEL]		メモリオブジェクトのラベル
	$memObj[key][:PLABEL]		メモリ保護単位のラベル
	$memObj[key][:SRPWLABEL]	標準共有リード専有ライト領域全体のラベル
	$datasecList				初期化すべきdataセクションのリスト
	$bsssecList					クリアすべきbssセクションのリスト

(A3-6) 仮のメモリ構成・初期化ファイル（kernel_mem2.c）の生成（kernel.trb）

・仮メモリオブジェクト初期化ブロックの生成
・仮dataセクション初期化ブロックの生成
・仮bssセクション初期化ブロックの生成

(A3-7) 仮アドレス変換テーブルの生成（core_kernel.trb）

(A3-8) 仮のリンカスクリプトの生成（ldscript.trb）

●パス3（自動メモリ配置の場合のみ）の詳細［USE_CFG_PASS3の場合のみ］

(A5-1) データセクションのLMAからVMAへのコピー（kernel_opt.trb）

(A5-2) シンボルと仮メモリオブジェクト初期化情報の読込み（kernel_opt.trb）

・シンボルと仮メモリオブジェクト初期化情報を読み，次の情報を作成する
	$memObj[key][:baseaddr]		メモリオブジェクトの先頭番地
	$memObj[key][:endaddr]		メモリオブジェクトの終了番地
	$memObj[key][:aendaddr]		メモリオブジェクトのアラインした終了番地

(A5-3) 仮のメモリ構成・初期化ファイル（kernel_mem3.c）の生成（kernel_opt.trb）

・仮メモリオブジェクト初期化ブロックのサイズ適正化と生成
・仮dataセクション初期化ブロックのサイズ適正化と生成
・仮bssセクション初期化ブロックのサイズ適正化と生成

(A5-4) 仮アドレス変換テーブルの生成（core_opt.trb）

(A5-5) 仮のリンカスクリプトの生成（オプション）（core_opt.trb）

●パス4（自動メモリ配置の場合のみ）の詳細

(A7-1) データセクションのLMAからVMAへのコピー（kernel_mem.trb）

(A7-2) シンボルと仮メモリオブジェクト初期化ブロックの読込み（kernel_mem.trb）

・シンボルと仮メモリオブジェクト初期化ブロックを読み，次の情報を作成する
	$memObj[key][:baseaddr]		メモリオブジェクトの先頭番地
	$memObj[key][:endaddr]		メモリオブジェクトの終了番地
	$memObj[key][:aendaddr]		メモリオブジェクトのアラインした終了番地
	$memObj[key][:poffset]		物理アドレスとのオフセット

(A7-3) メモリオブジェクト間に想定していない隙間がないかのチェック
		（kernel_mem.trb）

(A7-4) メモリオブジェクトの重なりのチェックとアドレス順のソート
		（kernel_mem.trb）⇒ SortMemtopList（kernel_lib.trb）

・メモリオブジェクトの重なりをチェックする．
・次の情報を生成する．
	$memObj[key][:maendaddr]	空のメモリオブジェクトを取り除いた後の
								メモリオブジェクトのアラインした終了番
								地
	$memObj[key][:MAEND_MLABEL]	[:maendaddr]に対応するメモリオブジェク
								トのラベル
	$memObj[key][:suppressend]	次のメモリオブジェクトと隣接しているか？
	$memObj[key][:merged]		併合されたユーザスタック領域か？
	$sortedMemtopList			メモリオブジェクトのベースアドレス順の
								リスト（空のメモリオブジェクトは含めな
								い，併合されたユーザスタック領域は含め
								ない，リンクオンリーセクションは含めな
								い）

 ※ $sortedMemtopListから空のメモリオブジェクトを取り除く際に，取り除
	いたメモリオブジェクトによってアラインしていると，$sortedMemtopList
	に含まれるメモリオブジェクトの間に予期しない隙間が生じてしまう．そ
	こで，取り除いたメモリオブジェクトによってアラインしている場合には，
	そのアラインした終了番地を，手前のメモリオブジェクトのアラインした
	終了番地に設定する．元のアラインした終了番地も残しておきたいので，
	補正後のアラインした終了番地は[:maendaddr]に設定する．また，そのラ
	ベルを[:MAEND_MLABEL]に設定する．

(A7-5) メモリ構成・初期化ファイル（kernel_mem.c）の生成（kernel_mem.trb）

・メモリオブジェクト初期化ブロックの生成
							⇒ GenerateMeminib（kernel_lib.trb）
・dataセクション初期化ブロックの生成
・bssセクション初期化ブロックの生成

(A7-6) メモリ保護単位に関する情報の生成（core_mem.trb）
							⇒ GenerateMemProt（kernel_lib.trb）

・メモリ保護単位に関する次の情報を生成（先頭番地順にソートする，リンク
  オンリーセクションは含めない）
	$memProt[key][:baseaddr]	メモリ保護単位の先頭番地
	$memProt[key][:aendaddr]	メモリ保護単位のアラインした終了番地
	$memProt[key][:poffset]		物理アドレスとのオフセット
	$memProt[key][:accatr]		メモリオブジェクトアクセス属性
	$memProt[key][:acptn1]		通常操作1（書込み）のアクセス許可パターン
	$memProt[key][:acptn2]		通常操作2（読出し，実行）のアクセス許可パターン
	$memProt[key][:domain]		属するドメイン（無所属の場合はTDOM_NONE）
	$memProt[key][:global]		メモリ保護属性が，すべてのユーザドメイで同
								一（ユーザドメインがない場合も含む）
	$memProt[key][:private]		メモリ保護属性が，属するユーザドメイン以外
								で同一（ユーザドメインに属する場合のみ有効）
	$memProt[key][:mokey]		先頭の（統合前の）メモリオブジェクトのキー

(A7-7) メモリ保護単位に関するエラーチェック（core_mem.trb）

・ATT_MEMで登録したメモリオブジェクトの先頭番地のチェック
・メモリ保護単位の境界のチェック

(A7-8) アドレス変換テーブルの生成（arm_mmu.trb）

・ARMセクション（1MB単位のメモリ領域）に関する情報の前処理
・ページテーブル領域の確保数に関する処理
・テーブルエントリ生成のための共通関数
・セクションテーブルの生成
・ページテーブルの生成

(A7-9) リンカスクリプトの生成（オプション）

●パス2（手動メモリ配置の場合）の詳細

(M3-1) ターゲット依存の定義（target_kernel.trb，core_kernel.trb）

(M3-2) メモリリージョンの情報の生成（memory_prep.trb）

ATT_REGとDEF_REGはサポートしない．これらの静的APIが記述されていれば，
警告メッセージを出して無視する．統合仕様書ではE_NOSPTエラーとなってい
るが，同一のコンフィギュレーションファイルを使えるようにするために，警
告としている（仕様を逸脱している）．

(M3-3) 静的APIからのメモリオブジェクトの情報の生成

以下を除いて，自動メモリ配置の場合の(A3-3)と同様に行う．

ATT_SECとATT_MODはサポートしないため，(A3-3-2)と(A3-3-3)の処理は行わな
い．これらの静的APIが記述されていれば，警告メッセージを出して無視する．
統合仕様書ではE_NOSPTエラーとなっているが，同一のコンフィギュレーショ
ンファイルを使えるようにするために，警告としている（仕様を逸脱してい
る）．

また，ユーザスタックの先頭番地は具体的な値で指定しなければならないため，
(A3-3-6)で$ustackListLinkerは空リストとなる．その結果，(A3-3-7)の処理
は行わない．さらに，固定長メモリプール領域の先頭番地も具体的な値で指定
しなければならないため，(A3-3-8)で$memObjに登録される情報はない．

(M3-4) メモリオブジェクトに関する情報とリストの作成（kernel.trb）
		※自動メモリ配置の場合の(A3-4)，(A3-5)，(A7-2)に対応する処理

・メモリオブジェクトの情報に，以下の修正を加える．
	$memObj[key][:acptn1]		通常操作1（書込み）のアクセス許可パター
								ン．メモリオブジェクト属性にTA_NOWRITEが
								設定されている場合は0にする

・メモリオブジェクトの情報に，以下の情報を追加する．
	$memObj[key][:accatr]		メモリオブジェクトアクセス属性
	$memObj[key][:linkonly]		リンクオンリーセクションか？

・メモリオブジェクトに関する次の情報を作成する．
	$memObj[key][:MP_TOP]		メモリ保護単位の先頭（すべてのメモリオ
								ブジェクトに対してtrueに設定）
	$memObjList					メモリオブジェクトの先頭のリスト

・メモリオブジェクトに関する次の情報を作成する．
	$memObj[key][:baseaddr]		メモリオブジェクトの先頭番地
	$memObj[key][:endaddr]		メモリオブジェクトの終了番地
	$memObj[key][:aendaddr]		メモリオブジェクトのアラインした終了番
								地（終了番地と同じ値）
	$memObj[key][:poffset]		物理アドレスとのオフセット

(M3-5) メモリオブジェクトの重なりのチェックとアドレス順のソート（kernel.trb）
							⇒ SortMemtopList（kernel_lib.trb）
		※自動メモリ配置の場合の(A7-4)に対応する処理

・メモリオブジェクトの重なりをチェックする．
・次の情報を生成する．
	$memObj[key][:maendaddr]	空のメモリオブジェクトを取り除いた後の
								メモリオブジェクトのアラインした終了番
								地
	$memObj[key][:MAEND_MLABEL]	[:maendaddr]に対応するメモリオブジェク
								トのラベル
	$memObj[key][:suppressend]	次のメモリオブジェクトと隣接している
	$memObj[key][:merged]		併合されたユーザスタック領域
	$sortedMemtopList			メモリオブジェクトのベースアドレス順の
								リスト（空のメモリオブジェクトは含めな
								い，併合されたユーザスタック領域は含め
								ない，リンクオンリーセクションは含めな
								い）

(M3-6) メモリ構成・初期化ファイル（kernel_mem.c）の生成（kernel.trb）
		※自動メモリ配置の場合の(A7-5)に対応する処理

・メモリオブジェクト初期化ブロックの生成
							⇒ GenerateMeminib（kernel_lib.trb）

(M3-9) メモリ保護単位に関する情報の生成（core_kernel.trb）
							⇒ GenerateMemProt（kernel_lib.trb）
		※自動メモリ配置の場合の(A7-6)に対応する処理

(M3-10) アドレス変換テーブルの生成（arm_mmu.trb）
		※自動メモリ配置の場合の(A7-8)に対応する処理

○自動メモリ配置と手動メモリ配置の中間的な方法（参考情報）

ここでは，自動メモリ配置と手動メモリ配置の中間的な方法について述べる．
ただし，この方法がうまく実装できるかは，さらに検討する必要がある．HRP3
カーネルでは，この方法はサポートしていない．

●方法の概要

ユーザは，リンカスクリプトを用意することで，オブジェクトモジュールやセ
クションをどの番地に配置するかを決定する（ここまでは，手動メモリ配置と
同じ）．コンフィギュレーション記述には，（どの番地をどのように保護する
かではなく）オブジェクトモジュールやセクションをどのように保護するかを
含める．

定められた制約を満たすリンカスクリプトを用意するのは，ユーザの責任であ
る．ここでいう制約には，ターゲットプロセッサが持つメモリ保護ユニットで
保護が可能であるための制約や，適切な番地に適切なラベルを置いておくといっ
た制約が含まれる．

一方，リンカスクリプトと整合するメモリ構成・初期化ファイルを生成するの
は，コンフィギュレータの責任である．リンカスクリプトが原因で，メモリ構
成・初期化ファイルが正しく生成できない場合には，コンフィギュレータはエ
ラーを報告する．

もう一歩進めて，ユーザが用意したリンカスクリプトに問題がある（例えば，
スタックオーバフローが検出できないメモリ配置になっている）場合に，コン
フィギュレータが警告することも可能である．

●方法の具体化

この方法では，ATT_MEMとATT_SECを用いる（保護ドメイン毎の標準セクション
のみをサポートし，ATT_SECをサポートしない手もある）．ATT_REGとDEF_SRG
は意味がない．ATT_MODは原理的にはサポートできるが，有効性が低いと考え
られるため，サポートしないこととする．

ユーザは，リンカスクリプトにおいて，各メモリ保護単位に対して，指定され
た名前の先頭ラベルとアラインさせた終了ラベルを置かなければならないもの
とする．以下，具体例で考えていく．

まずは，保護ドメイン毎の標準セクションのみをサポートし，ATT_SECをサポー
トしない場合を考える．この場合は，用いた保護ドメイン毎に，標準のメモリ
保護単位の先頭ラベルとアラインさせた終了ラベルを，リンカスクリプトで定
義しなければならないものとする．例えば，保護ドメインDOM1を用いたら，以
下のラベルを定義しなければならない（ラベルが定義されない時は，そのセク
ションはないものと扱う）．

	__start_text_DOM1		… DOM1のプログラム領域
	__aend_text_DOM1
	__start_rodata_DOM1		… DOM1の専有リードオンリーデータ領域
	__aend_rodata_DOM1
	__start_rwdata_DOM1		… DOM1の専有リード／ライト領域
	__aend_rwdata_DOM1
	__start_srpw_DOM1		… DOM1の共有リード専有ライト領域
	__aend_srpw_DOM1
	※ ターゲット定義で，rodataをtextに含めても良い．

また，以下のラベルを定義しなければならない．

	__start_text_shared		… 共有のプログラム領域
	__aend_text_shared
	__start_rodata_shared	… 共有のリードオンリーデータ領域
	__aend_rodata_shared
	__start_rwdata_shared	… 共有リードライト領域
	__aend_rwdata_shared
	__start_srpw_all		… 共有リード専有ライト領域の全体
	__aend_srpw_all

さらに，ターゲットによっては，ショートデータ領域のためのラベルも必要に
なる．

次にATT_SECをサポートする場合を考える．ATT_SECされたセクションが標準の
保護属性（アクセス許可ベクタ，メモリオブジェクト属性）でない場合，その
セクションを含むメモリ保護単位の先頭ラベルとアラインさせた終了ラベルを，
リンカスクリプトで定義しなければならないものとする．メモリ保護単位の先
頭ラベルと上限ラベルの付け方は要検討（今のラベルを変えたくないところだ
が，ユーザにはわかりにくい）．

セクションを含むメモリ保護単位ではなく，セクションの先頭ラベルと保護終
了ラベルとする手もある（その方が，ユーザにはわかりやすい）が，同じ保護
属性を持つセクションが複数ある場合に，それを統合することができない．同
じ保護属性を持つセクションは1つに限定し，統合はしないという制限を加え
る手は考えられる．

この方法の欠点は，手動メモリ配置と同様，ユーザがターゲットプロセッサの
メモリ保護機能を知っていることが必要になることである．ただし，ターゲッ
トプロセッサへの依存性を，リンカスクリプトを作成する際の制約に落としこ
むことは可能であろう．

また，この方法にも，手動メモリ配置と同様，dataセクションとbssセクション
の初期化情報をユーザが記述しなければならないという欠点がある．

以上
